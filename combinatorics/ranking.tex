\chapter{Rangul permutărilor și al combinărilor}

\href{https://sepi.ro/assets/upload-file/oni2024/Programa\%20pentru\%20olimpiada\%20de\%20informatica_gimnaziu\%20si\%20liceu.pdf}{Programa de clasa a 10-a conține} și \textit{Determinarea numărului de ordine pentru elementele combinatoriale}. Ceea ce poate însemna orice din vreo 10 subiecte diferite. \emoji{slightly-smiling-face}

Vom discuta despre permutări și combinări. Aceleași principii se aplică și la alte elemente combinatoriale (aranjamente, submulțimi etc.).

\section{Definiții}

\textbf{Rangul} unui obiect este numărul lui de ordine în lista ordonată a tuturor obiectelor de acel tip. Exemple:

\begin{itemize}
  \item Rangul permutării (3 1 2) este 4 (pornind de la 0). Cele 4 permutări anterioare, în ordine, sînt (1 2 3), (1 3 2), (2 1 3) și (2 3 1).

  \item Rangul combinării de 5 luate cîte 3 (1 4 5) este 5. Combinările anterioare sînt (1 2 3), (1 2 4), (1 2 5), (1 3 4), (1 3 5).
\end{itemize}

Vom folosi termenii englezești \textit{ranking} pentru aflarea rangului unui obiect dat și \textit{unranking} pentru aflarea obiectului dîndu-i-se rangul. Ordinea lexicografică nu este unica posibilă. De exemplu, problema \hyperref[problem:arbperm2]{Arbperm2} specifică altă ordine, iar în problemele \hyperref[problem:inversion-sort]{Inversion Sort} și \hyperref[problem:four-chips]{Four Chips} sîntem liberi să ne alegem orice ordine, singurul scop fiind să mapăm permutări/combinări la întregi ca să ținem evidența obiectelor deja întîlnite.

\textbf{Următorul obiect} al unui obiect dat este obiectul de rang cu 1 mai mare. Exemple:

\begin{itemize}
  \item Permutarea care urmează după (3 1 2) este (3 2 1).
  \item Combinarea de 5 luate cîte 3  care urmează după (1 4 5) este (2 3 4).
\end{itemize}

Aveți deja toate uneltele ca să calculați ad-hoc toate aceste informații, dar este bine să ne familiarizăm cu unele subtilități.

\section{Rangul permutărilor}

\subsection{Următoarea permutare}

Fie permutările

\begin{align*}
P &= (2\ 5\ 4\ 8\ 7\ 6\ 3\ 1\ 0)\\
next(P) &= (2\ 5\ 6\ 0\ 1\ 3\ 4\ 7\ 8)
\end{align*}

Procedura pentru a trece de la $P$ la $next(P)$ este simplă:

\begin{enumerate}
  \item Găsește cel mai lung sufix descrescător, $(8\ 7\ 6\ 3\ 1\ 0)$.
  \item Schimbă elementul anterior sufixului, $4$, cu cel mai mic element din sufix mai mare decît acesta ($6$).
  \item Răstoarnă sufixul.
\end{enumerate}

Complexitatea amortizată pentru mai multe apeluri este $\bigoh(1)$ (de ce?). Cred că funcția din STL \ccode{std::next_permutation()} aplică fix acest algoritm. Ea garantează că face cel mult $n/2$ interschimbări (de ce?).

\subsection{\textit{Ranking}}

Deoarece $21! > 2^{64}$, calculul complet este de interes doar pentru permutări de cel mult 20 de elemente (problema \hyperref[problem:inversion-sort]{Inversion Sort}). În rest, trebuie să operați cu ranguri fără a le calcula efectiv.

Calculați manual rangul pe exemplul de mai sus (103679)! Vom deduce că întrebarea esențială este: pentru o poziție dată $k$, cîte valori mai mici decît $P(k)$ se află pe pozițiile anterioare?

\subsection{\textit{Unranking}}

Întrebarea de bază la \textit{unranking} este cea inversă: care este valoarea potrivită de așezat la poziția curentă? Ea va fi a $k$-a valoare cu proprietatea că numărul de permutări care încep cu primele $k-1$ valori însumate nu depășește rangul dorit, dar dacă includem și a $k$-a valoare depășim rangul.

Pentru ordinea naturală (lexicografică), algoritmul se reduce la o împărțire la $(n-k)!$ și la întrebarea: care este a $k$-a cea mai mică valoare încă nescrisă la stînga poziției curente?

Calculați permutarea din rangul de mai sus!

\subsection{Implementare}

Putem răspunde la aceste întrebări în timp total $\bigoh(n \log n)$ folosind un AIB sau alte structuri cu interogare în timp logaritmic. Atenție însă, pentru $n$ mic implementarea naivă (pătratică) va fi mai rapidă. În schimb, putem cîștiga timp folosind măști de biți.

Pentru \textit{unranking}, trebuie să răspundem rapid la întrebarea: care este al $k$-lea bit zero dintr-o mască de biți? O variantă este să precalculăm acest răspuns pentru toate măștile. Dar pentru $n = 20$, aceasta va necesita memorie $2^n \cdot n = 20$ MB, ceea ce nu este ideal. Există și o operație primitivă, PDEP, dar ea nu este implementată pe toate arhitecturile și poate funcționa chiar mai lent decît căutarea naivă.

\label{problem:combinatorics-perm-rank}

Vom citi \hyperref[code:combinatorics-perm-rank]{implementările} acestor algoritmi. Iată și un \textit{benchmark} pentru $n = 20$:

\begin{verbatim}
[cata@neil combinatorics]$ ./permutation-rank
inițializare: 942 ms pentru 10000000 operații (10 Mops/sec)
--
rank naiv: 890 ms pentru 10000000 operații (11 Mops/sec)
rank cu AIB: 1984 ms pentru 10000000 operații (5 Mops/sec)
rank cu popcount: 180 ms pentru 10000000 operații (55 Mops/sec)
--
unrank naiv: 3424 ms pentru 10000000 operații (2 Mops/sec)
unrank cu AIB: 4016 ms pentru 10000000 operații (2 Mops/sec)
unrank cu popcount și tabel: 1195 ms pentru 10000000 operații (8 Mops/sec)
unrank cu popcount și pdep: 5739 ms pentru 10000000 operații (1 Mops/sec)
\end{verbatim}

\section{Rangul combinărilor}

În cazul combinărilor, discuțiile sînt mai nuanțate. Problemele de rang au valori mici pentru $k$, dar nu neapărat și pentru $n$. Bunăoară, pentru $k = 3$, valoarea maximă pentru $n$ astfel încît $C_{n}^{k} < 2^{64}$ (adică rangul să încapă pe \ccode{unsigned long long}) este circa 2.000.000, pe cînd pentru $k = 20$, valoarea maximă pentru $n$ este 86.

\subsection{Următoarea combinare}

Să analizăm un exemplu. Fie combinarea de 20 luate cîte 6 (numerotate de la 0):

\begin{align*}
C &= (4\ 7\ 12\ 17\ 18\ 19) \\
next(C) &= (4\ 7\ 13\ 14\ 15\ 16)
\end{align*}

Rezultă că algoritmul este:

\begin{enumerate}
  \item Găsește ultima poziție $i$ pentru care $C[i] - i < n - k$.

  \item Dacă acea poziție nu există, atunci $C$ este ultima lexicografic.

  \item Altfel, incrementează $C[i]$ și pe toate pozițiile $j > i$ atribuie $C[j] = C[j - 1] + 1$.
\end{enumerate}

Și acest algoritm are complexitate amortizată $\bigoh(1)$ (de ce?).

\subsection{\textit{Ranking} lexicografic}

Să considerăm combinarea de 4 elemente dintr-un set de 20 (numerotate începînd de la 0):

$$C = (4\ 7\ 13\ 16)$$

Dacă dorim să îi calculăm rangul lexicografic, atunci facem următoarele observații:

\begin{itemize}
  \item Există $C_{19}^{3} = 969$ combinări care încep cu 0, deoarece dacă îl alegem pe 0 mai rămîn 19 alte elemente din care trebuie să alegem 3.
  \item Există $C_{18}^{3} = 816$ combinări care încep cu 1.
  \item Există $C_{17}^{3} = 680$ combinări care încep cu 2.
  \item Există $C_{16}^{3} = 560$ combinări care încep cu 3.
  \item Toate combinările de mai sus sînt mai mici lexicografic decît $P$.
  \item Există $C_{14}^{2} = 91$ combinări care încep cu 4 5, deoarece mai rămîn valorile 6-19 din care trebuie să alegem două.
  \item Există $C_{13}^{2} = 78$ combinări care încep cu 4 6.
  \item Există $C_{11}^1 = 11$ combinări care încep cu 4 7 8.
  \item \dots
  \item Există $C_{7}^1 = 7$ combinări care încep cu 4 7 12.
  \item Există $C_{5}^0 = 1$ combinări care încep cu 4 7 13 14.
  \item Există $C_{4}^0 = 1$ combinări care încep cu 4 7 13 15.
\end{itemize}

Rangul lui (4 7 13 16) este suma combinărilor de mai sus, adică 3241.

Algoritmul funcționează în $\bigoh(n)$. El poate fi îmbunătățit pînă la $\bigoh(k)$ cu formula

$$\sum_{m = 0}^{n} C_m^k = C_{n+1}^{k+1}$$

\subsection{\textit{Unranking} lexicografic}

Calculați combinarea din rangul de mai sus! Algoritmul naiv funcționează în $\bigoh(n + k)$ urmînd exact pașii de mai sus. De exemplu, va scădea succesiv valorile 919, 816, 680 și 560 din rangul dat și va constata că nu mai poate scădea încă $C_{15}^3 = 455$, deci primul element trebuie să fie 4.

Putem reduce complexitatea la $\bigoh(k + \log n)$ folosind sume parțiale și căutări binare. Nu sînt sigur dacă există vreun algoritm în $\bigoh(k)$.

\subsection{\textit{Ranking} și \textit{unranking} colexicografic}

O altă ordine notabilă este \href{https://en.wikiversity.org/wiki/Lexicographic_and_colexicographic_order}{ordinea colexicografică}. În acestă ordine, combinările sînt ordonate de la dreapta către stînga. Ne ajută mai mult să considerăm că elementele au valori între $0$ și $n-1$, iar pozițiile între $0$ și $k-1$, ca în tabelul următor:

\begin{table}[H]
  \centering
  \begin{tabular}{ccc}
    \textbf{rang} & \textbf{combinare} & \textbf{proveniență}\\
    \hline
     0 & (0 1 2) & $C_0^1 + C_1^2 + C_2^3$ \\
     1 & (0 1 3) & $C_0^1 + C_1^2 + C_3^3$ \\
     2 & (0 2 3) & $C_0^1 + C_2^2 + C_3^3$ \\
     3 & (1 2 3) & $C_1^1 + C_2^2 + C_3^3$ \\
     4 & (0 1 4) & $C_0^1 + C_1^2 + C_4^3$ \\
     5 & (0 2 4) & $C_0^1 + C_2^2 + C_4^3$ \\
     6 & (1 2 4) & $C_1^1 + C_2^2 + C_4^3$ \\
     7 & (0 3 4) & $C_0^1 + C_3^2 + C_4^3$ \\
     8 & (1 3 4) & $C_1^1 + C_3^2 + C_4^3$ \\
     9 & (2 3 4) & $C_2^1 + C_3^2 + C_4^3$ \\
    10 & (0 1 5) & $C_0^1 + C_1^2 + C_5^3$ \\
    11 & (0 2 5) & $C_0^1 + C_2^2 + C_5^3$ \\
    12 & (1 2 5) & $C_1^1 + C_2^2 + C_5^3$ \\
    13 & (0 3 5) & $C_0^1 + C_3^2 + C_5^3$ \\
    14 & (1 3 5) & $C_1^1 + C_3^2 + C_5^3$ \\
    15 & (2 3 5) & $C_2^1 + C_3^2 + C_5^3$ \\
    16 & (0 4 5) & $C_0^1 + C_4^2 + C_5^3$ \\
    17 & (1 4 5) & $C_1^1 + C_4^2 + C_5^3$ \\
    18 & (2 4 5) & $C_2^1 + C_4^2 + C_5^3$ \\
    19 & (3 4 5) & $C_3^1 + C_4^2 + C_5^3$ \\
    \hline
  \end{tabular}

  \caption{Combinări de $n=6$ luate cîte $k=3$, ordonate colexicografic}
\end{table}

Calculul rangului unei combinări este facil în $\bigoh(k)$. Să luăm exemplul combinării $X$ = (2 3 5) și să procedăm de la dreapta la stînga.

\begin{itemize}
  \item Toate combinările terminate cu 2, 3 sau 4 vin înaintea lui $X$. Numărul lor este exact numărul de combinări care folosesc doar valorile 0, 1, 2, 3 sau 4, deci $C_5^3$.
  \item Similar, combinările terminate cu ($a$ 5), unde $a < 3$, vin înaintea lui $X$. Numărul lor este $C_3^2$.
  \item În sfîrșit, combinările terminate cu ($b$ 3 5), unde $b < 2$, vin înaintea lui $X$. Numărul lor este $C_2^1$. Astfel obținem rangul lui $X$, 10 + 3 + 2 = 15.
\end{itemize}

\begin{minted}{c}
u64 rank_colex(int* c) {
  u64 result = 0;
  for (int i = 0; i < K; i++) {
    result += choose[c[i]][i + 1];
  }
  return result;
}
\end{minted}

Și partea de \textit{unranking} este simplă în $\bigoh(n)$. Să pornim cu rangul 5. Vom completa combinarea $X$ de la dreapta la stînga.

\begin{itemize}
  \item Ar putea ultima valoare să fie 5? Știm că există $C_5^3 = 10$ combinări care folosesc doar valorile 0-4 și toate ar trebui să vină înaintea lui $X$. Dar $10 > 5$, deci ultima valoare \textbf{nu} poate fi 5.
  \item Ar putea ultima valoare să fie 4? Știm că există $C_4^3 = 4$ combinări care folosesc doar valorile 0-3 și toate ar trebui să vină înaintea lui $X$. Deoarece $4 \leq 5$, ultima valoare este 4. Scădem 4 din rang și dorim să aflăm permutarea de rang 1 dintre cele terminate cu 4.
  \item Ar putea penultima valoare să fie 3? Știm că există $C_3^2 = 3$ moduri de a lua două din valorile 0-2 și toate ar trebui să vină înaintea lui $X$. Deoarece $3 > 1$, penultima valoare \textbf{nu} poate fi 3.
  \item Ar putea penultima valoare să fie 2? Știm că există $C_2^2 = 1$ mod de a lua două din valorile 0-1 și el ar trebui să vină înaintea lui $X$. Deoarece $1 \leq 1$, penultima valoare este 2. Scădem 1 din rang și dorim să aflăm permutarea de rang 0 dintre cele terminate cu 2 4.
  \item Similar raționăm că prima valoare nu poate fi 1, dar va fi 0. Aflăm că $X$ = (0 2 4).
\end{itemize}

\begin{minted}{c}
void unrank_colex(u64 rank, int* dest) {
  int n = N - 1;
  for (int k = K; k; k--) {
    while (choose[n][k] > rank) {
      n--;
    }
    rank -= choose[n][k];
    dest[k - 1] = n;
  }
}
\end{minted}

\label{problem:combinatorics-comb-rank}

\hyperref[code:combinatorics-comb-rank]{Implementarea completă} este anexată.
