\section{Probleme}

Primele 8 probleme sînt educaționale, clasice.

\subsection{Problema Binomial Coefficients (CSES)}
\label{problem:binomial-coefficients}

\href{https://cses.fi/problemset/task/1079}{enunț}
$\bullet$
\hyperref[code:binomial-coefficients]{sursă}

Este o problemă clasică de calcul al combinărilor. Pentru a calcula $C_n^k = \frac{n!}{k!(n-k)!}$ avem nevoie de inversele factorialelor. Repet că le putem calcula pe toate $n$ în $\bigoh(n)$.

\subsection{Problema Creating Strings II (CSES)}
\label{problem:creating-strings-2}

\href{https://cses.fi/problemset/task/1715}{enunț}
$\bullet$
\hyperref[code:creating-strings-2]{sursă}

Este o problemă clasică de permutări cu repetiție. Ca optimizare, cum rezolvăm problema fără memorie $\bigoh(n)$, ci doar $\bigoh(\Sigma)$?

\subsection{Problema Distributing Apples (CSES)}
\label{problem:distributing-apples}

\href{https://cses.fi/problemset/task/1716}{enunț}
$\bullet$
\hyperref[code:distributing-apples]{sursă}

Este o problemă clasică de combinări cu repetiție (\textit{Stars and bars}). Atenție la implicația tacită: copiii sînt distincți (contează dacă Gigel primește un măr și Ionel două sau invers), dar merele sînt identice (nu contează care sînt cele două mere primite de Ionel).

\subsection{Problema Christmas Party (CSES)}
\label{problem:christmas-party}

\href{https://cses.fi/problemset/task/1717}{enunț}
$\bullet$
\hyperref[code:christmas-party]{surse}

Este o problemă clasică de numărare a permutărilor fără puncte fixe. Includ trei surse, două cu principiul includerii și excluderii și una cu formula de recurență.

\subsection{Problema Bracket Sequences I (CSES)}
\label{problem:bracket-sequences-1}

\href{https://cses.fi/problemset/task/2064}{enunț}
$\bullet$
\hyperref[code:bracket-sequences-1]{sursă}

Este o problemă elementară de calcul al numărului lui Catalan.

\subsection{Problema Bracket Sequences II (CSES)}
\label{problem:bracket-sequences-2}

\href{https://cses.fi/problemset/task/2187}{enunț}
$\bullet$
\hyperref[code:bracket-sequences-2]{sursă}

Probleme cere să calculăm numărul de parantezări cu prefix impus.

\subsection{Problema Counting Necklaces (CSES)}
\label{problem:counting-necklaces}

\href{https://cses.fi/problemset/task/2209}{enunț}
$\bullet$
\hyperref[code:counting-necklaces]{sursă}

Este o aplicație directă a Lemei lui Burnside.

\subsection{Problema Counting Grids (CSES)}
\label{problem:counting-grids}

\href{https://cses.fi/problemset/task/2209}{enunț}
$\bullet$
\hyperref[code:counting-grids]{sursă}

Și acestă problemă este o aplicație directă a Lemei lui Burnside.

\subsection{Problema Number of Permutations (Codeforces)}
\label{problem:number-of-permutations}

\href{https://codeforces.com/contest/1207/problem/D}{enunț}
$\bullet$
\hyperref[code:number-of-permutations]{sursă}

Problema este directă, rezolvabilă cu principiul includerii și excluderii. Din toate cele $n!$ permutări,

\begin{itemize}
  \item le scădem pe cele sortate după $a$;
  \item le scădem pe cele sortate după $b$;
  \item le adunăm pe cele sortate simultan după $a$ și după $b$.
\end{itemize}

Sursa include și un exemplu de inginerie care vă poate ajuta. Ca să evităm duplicarea (sau triplicarea) codului, putem trimite funcții ca parametru.

\subsection{Problema Counting Factorizations (Codeforces)}
\label{problem:counting-factorizations}

\href{https://codeforces.com/contest/1794/problem/D}{enunț}
$\bullet$
\hyperref[code:counting-factorizations]{sursă}

Soluția urmează \href{https://codeforces.com/blog/entry/113500}{editorialul}, care este bine scris.

Să remarcăm că, dacă $f(m) = \{a_1, a_2, \dots, a_{2n}\}$, atunci $n$ dintre cele $2n$ numere citite la intrare trebuie să fie bazele, numere prime și distincte. Altfel problema nu are soluție. Sursa nu tratează special acest caz, dar el merita remarcat. Deoarece $n$ dintre numere trebuie să fie prime, să citim cele $n$ numere și să le clasificăm în prime și compuse (pe 1 îl tratăm ca număr compus). Putem folosi testul naiv de primalitate, fiind vorba despre doar $\np{2022}$ de numere mici.

Mai departe, să remarcăm că exponenții nu trebuie neapărat să fie distincți. De aceea, cele $n$ numere rămase după alegerea bazelor pot fi permutate, dar cu eliminarea repetițiilor. De aceea, nu ne interesează numerele însele, ci frecvențele acestora. Să spunem că avem $p$ numere prime distincte cu frecvențele $g_1, g_2,\dots, g_p$ și $c$ numere compuse distincte cu frecvențele $h_1, h_2, \dots, h_c$.

Orice mod de a construi un $m$ înseamnă că $n$ dintre frecvențele numerelor prime vor scădea cu 1 (acelea sînt bazele alese). Să notăm frecvențele rămase cu $g_1', g_2', \dots, g_p'$, unde $g_i' = g_i$ sau $g_i' = g_i - 1$. Celelalte numere rămase reprezintă cei $n$ exponenți, iar frecvențele lor sînt $g_1', g_2', \dots, g_p', h_1, h_2, \dots h_c$ (unele dintre aceste valori pot fi 0). Numărul de moduri de a permuta acești exponenți pentru a obține $m$-uri diferite este:

$$\frac{n!}{g_1'! g_2'! \dots g_p'! h_1! h_2! \dots h_c!}$$

Acum trebuie să însumăm această cantitate peste toate modalitățile de atribuire a valorilor $g_i'$. Scoatem factor comun expresia

$$T = \frac{n!}{h_1! h_2! \dots h_c!}$$

și rămîne să însumăm rezultatele posibile pentru

$$\frac{1}{g_1'! g_2'! \dots g_p'!}$$

Aici ne permitem să aplicăm o programare dinamică de complexitate $\bigoh(n^2)$. Fie $d(i, j)$ suma termenilor de forma

$$\frac{1}{g_1'! g_2'! \dots g_i'!}$$

unde exact $j$ dintre factorii $g'$ sînt \textbf{diferiți} de factorul $g$ corespunzător (adică am ales $j$ numere prime dintre primele $i$ frecvențe). Atunci pe poziția $i$ putem să alegem valoarea $g_i' = g_i$ sau valoarea $g_i' = g_i - 1$. Rezultă recurența:

$$d(i, j) = \frac{1}{g_i!} \cdot d(i - 1, j) + \frac{1}{(g_i - 1)!} \cdot d(i - 1, j - 1)$$

Aici, primul termen semnifică că \textbf{nu} am folosit un număr prim din frecvența $g_i$, deci dintre primele $i-1$ numere prime încă avem de ales $j$, iar al doilea termen semnifică că am folosit un număr prim din frecvența $g_i$, deci pînă la $i-1$ mai avem de ales $j-1$ numere prime. Răspunsul la problemă va fi $T \cdot d(p, n)$.

Putem implementa programarea dinamică folosind un singur vector.

\subsection{Problema Monocarp and the Set (Codeforces)}
\label{problem:monocarp-and-the-set}

\href{https://codeforces.com/contest/1886/problem/D}{enunț}
$\bullet$
\hyperref[code:monocarp-and-the-set]{sursă}

Problema necesită o mică observație, dar sper să aveți deja acest reflex format. Este mult mai simplu să considerăm operațiile de la sfîrșit spre început. Iau naștere trei cazuri:

\begin{itemize}
  \item Dacă ultimul caracter este \texttt{>}, atunci ultimul număr inserat este $n$. Reducem problema la una identică de mărime $n-1$.

  \item Similar, dacă ultimul caracter este \texttt{<}, atunci ultimul număr inserat este $1$.

  \item Dacă ultimul caracter este \texttt{?}, atunci avem $n-2$ variante pentru ultimul număr inserat. Problema se reduce tot la una identică de mărime $n-1$, dar nu direct, ci printr-o renumerotare. De exemplu, dacă am alege să punem \texttt{3} pe ultima poziție, atunci mulțimea numerelor anterioare ar fi $\{ 1, 2, 4, 5, 6 \}$, pe care însă o putem trata ca și pe $\{ 1, 2, 3, 4, 5 \}$ fără a schimba natura problemei.
\end{itemize}

De aceea, este suficient să menținem produsul valorilor $p$ pentru pozițiile $p$ care conțin caracterul \texttt{?}. Aritmetica ține cu noi dacă indexăm șirul natural, de la 0. Cu alte cuvinte, poziția 0 de la intrare corespunde celui de-al doilea element din permutare. Apoi, ori de cîte ori poziția $pos$ capătă valoarea \texttt{?}, înmulțim acest produs cu $pos$. Ori de cîte ori poziția $pos$ capătă valoarea \texttt{<} sau \texttt{>} înmulțim produsul cu inversul lui $pos$.

Este nevoie de un caz special cînd \ccode{s[1] = '?'}, deoarece 0 nu are invers. În acel caz, răspunsul este oricum 0, deoarece după primul număr inserat, al doilea va fi obligatoriu fie minim (\texttt{<}), fie maxim (\texttt{>}).

\subsection{Problema Devu and Flowers (Codeforces)}
\label{problem:devu-and-flowers}

\href{https://codeforces.com/contest/451/problem/E}{enunț}
$\bullet$
\hyperref[code:devu-and-flowers]{surse}

Problema este o formă de \textit{stars and bars}. În loc să punem $s$ obiecte în $n$ cutii, trebuie să le luăm, dar matematica este aceeași. În plus, cutiile au capacități. Spunem că o distribuție \textit{saturează} o cutie de capacitate $f_i$ dacă ia strict mai mult de $f_i$ obiecte din cutie.

Limita $n \leq 20$ este un indiciu puternic că soluția va fi exponențială în numărul de cutii. De aici ajungem la următoarea soluție cu principiul includerii și excluderii:

\begin{itemize}
  \item Numărăm toate cele $C_{s + n - 1}^{n-1}$ distribuții, care saturează 0 sau mai multe cutii.
  \item Scădem toate distribuțiile care saturează cel puțin o cutie.
  \item Adăugăm toate distribuțiile care saturează cel puțin două cutii.
  \item etc.
\end{itemize}

Odată ce fixăm mulțimea de cutii de saturat, cum anume le saturăm? Răspunsul este: plasăm $f_{i} + 1$ obiecte în fiecare cutie saturată $i$. Apoi distribuim restul de obiecte cu metoda \textit{stars and bars} simplă, ceea ce, eventual, va adăuga și alte obiecte în cutiile saturate. Astfel ne asigurăm că generăm toate distribuțiile cu care am putea satura respectivele cutii.

\subsubsection*{Detalii de implementare}

Toate combinările de calculat for avea forma $C_x^{n-1}$, unde $n$ este constant, iar $x$ este de ordinul a $10^{14}$. De aceea, nu putem folosi formula naturală

$$\frac{x!}{(x - n + 1)! \cdot (n-1)!}$$

întrucît nu putem calcula factoriale atît de mari. În schimb, putem folosi formula

$$\frac{x \cdot (x - 1) \cdot \dots \cdot (x - n + 2)}{(n-1)!}$$

Ca optimizare, putem precalcula numitorul la începutul problemei. Astfel ia naștere prima sursă.

Putem chiar să definim constante pentru numitorul $1/(n-1)!$ pentru cele 20 de valori posibile pentru $n$. Sursa se scurtează, căci putem renunța la codul pentru calcularea inverselor. Totuși, sursa pierde din claritate.

Pentru elevii care se dau în vînt după programe scurte, indiferent de claritate, am scris și o ultimă \href{https://codeforces.com/contest/451/submission/303384615}{sursă} aliniată la standardele de lizibilitate ale lui Codeforces!

\subsection{Problema Lengthening Sticks (Codeforces)}
\label{problem:lengthening-sticks}

\href{https://codeforces.com/contest/571/problem/A}{enunț}
$\bullet$
\hyperref[code:lengthening-sticks]{sursă}

\subsubsection*{Soluție directă}

Există o soluție bazată pe numărare directă, dar are multe cazuri particulare. Fie $x$, $y$ și $z$ cantitățile adăugate la $a$, $b$ și respectiv $c$. Iterăm prin toate valorile lui $z$ de la $0$ la $l$ și scriem inegalitățile în $x$ și $y$ care rezultă din inegalitatea triunghiului. De exemplu:

$$(a + x) < (b + y) + (c + z) \implies x - y < b + c - a + z$$

Astfel deducem limite superioare și inferioare pentru $x+y$ și $x-y$. Acestea delimitează un dreptunghi în planul $xOy$ rotit cu $45\degree$. Aria acestui dreptunghi este ușor de aflat. Din păcate, dreptunghiul mai trebuie decupat cu condițiile suplimentare $x \geq 0$ și $y \geq 0$, ceea ce duce la figuri complicate.

\subsubsection*{Soluție prin excludere}

O altă abordare este să numărăm toate modurile de a distribui cel mult $l$ unități, apoi să excludem tripletele ilegale.

Știm că putem distribui \textbf{exact} $l$ unități în $C_{l+2}^l$ moduri (este o problemă clasică de \textit{stars and bars}). Rezultă că numărul de moduri de a distribui cel mult $l$ unități este

$$C_{l+2}^{l} + C_{(l-1)+2}^{l-1} + \dots + C_2^0$$

Această sumă este egală cu $C_{l + 3}^{3}$ (vezi equația \ref{eq:comb-sum-3}). Dacă preferați, putem introduce un al patrulea băț fictiv care să preia surplusul din $l$ nefolosit cu $a$, $b$ și $c$. Ajungem la aceeași formulă. Ea poate fi calculată și cu un \ccode{for} în $\bigoh(l)$.

Acum să trecem la excludere. Din nou, fie $x$, $y$ și $z$ cantitățile adăugate la $a$, $b$ și respectiv $c$. Presupunem că dorim ca $a+x \geq b + y + c + z$ (vom proceda similar pentru $b+y$ și pentru $c+z$). Obținem inegalitățile:

$$
\begin{cases}
y + z & \leq l - x\\
y + z & \leq a + x - b - c
\end{cases}
$$

Fie $h = \min(l - x, a + x - b - c)$ limita superioară pentru $y+z$. Dacă $h$ este negativ, nu există combinații valide pentru $x$ și $y$. Dacă $h \geq 0$, atunci numărul de combinații valide este

$$0 + 1 + \dots + (h + 1) = \frac{(h + 1)(h + 2)}{2}$$

\subsection{Problema Shuffle (Codeforces)}
\label{problem:shuffle}

\href{https://codeforces.com/contest/1622/problem/D}{enunț}
$\bullet$
\hyperref[code:shuffle]{surse}

Ca la orice problemă de numărare, trebuie să ne asigurăm de două lucruri:

\begin{enumerate}
  \item Că numărăm toate posibilitățile.

  \item Că nu numărăm nicio posibilitate de mai multe ori.
\end{enumerate}

Facem și observația universală că șirul dat trebuie să aibă cel puțin $k$ caractere \texttt{1}.
\subsubsection*{Soluția în \texorpdfstring{$\bigoh(n^2)$}{O(n²)}}

Este tentant să încercăm următoarea abordare: pentru fiecare subsecvență $W = [l, r]$ adăugăm la răspuns cantitatea $C_{r-l+1}^x$, unde $x$ este numărul de caractere \texttt{1} din $W$. Dar este incorect, căci vom număra și unele permutări care lasă nemodificate porțiuni din $W$. Din această cauză, două subsecvențe parțial suprapuse, $W$ și $W'$, vor număra de două ori permutările care modifică doar zona comună $W \cap W'$.

Să contabilizăm subsecvențele într-un mod care elimină duplicatele. Fie $[l,r]$ o subsecvență amestecată astfel încît $l$ și $r$ sînt prima, respectiv ultima poziție modificată. Secvența merită luată în calcul dacă întrunește trei condiții:

\begin{enumerate}
  \item Are lungime cel puțin 2. O secvență de lungime 1 nu poate fi amestecată. \emoji{thinking-face}

  \item Conține cel mult $k$ cifre 1. Mai multe nu avem voie să selectăm, dar putem selecta mai puține (ne prefacem că amestecăm o secvență care include $[l,r]$, dar lasă nemodificate prefixul și sufixul).

  \item Secvența conține cifrele necesare pentru a nega pozițiile $l$ și $r$. Dacă $s[l] = s[r] = 1$, secvența trebuie să conțină și două zerouri. Similar dacă $s[l] = s[r] = 0$. Iar dacă $s[l] \neq s[r]$, atunci nu mai punem alte condiții, căci întotdeauna putem interschimba $s[l]$ cu $s[r]$.
\end{enumerate}

Odată fixate capetele, adăugăm la răspuns o cantitate de forma $C_{x+y}^x$.

\subsubsection*{Soluția în \texorpdfstring{$\bigoh(n)$}{O(n)}}

Iată un alt mod de a privi condiția (2). Cînd alegem o subsecvență care conține \textbf{exact} $k$ de 1 și o permutăm, unele dintre permutări vor lăsa nemodificate un prefix și un sufix al subsecvenței. În acele situații este ca și cînd am permuta o subsecvență cu \textbf{cel mult} $k$ de 1.

Pornind de la această observație, putem optimiza soluția de mai sus astfel. Să fixăm doar capătul stîng, $l$. Atunci capătul drept $r$ poate fi oriunde începînd de la $l+1$ pînă la cea de-a $k$-a apariție a unui \texttt{1}, plus toate zerourile următoare. Apoi, impunem o singură condiție:

\begin{enumerate}
  \item Undeva în $[l+1,r]$ există un caracter diferit de $s[l]$. Altfel nu ne putem  asigura că prima modificare este pe poziția $l$.
\end{enumerate}

Odată fixat capătul stîng, orice amestecare distinctă a caracterelor din $[l,r]$, cîtă vreme garantează că îl modifică pe $s[l]$, este o soluție distinctă și numărată o singură dată. Dacă am grupa acum aceste amestecări după poziția ultimului caracter modificat, $r$, am regăsi subsecvențele $[l,r]$ din soluția anterioară.
