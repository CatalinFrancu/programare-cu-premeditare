\section{Probleme}

\subsection{Problema Fixed-Length Paths I (CSES)}
\label{problem:fixed-length-paths-1}

\href{https://cses.fi/problemset/task/2080}{enunț}
$\bullet$
\hyperref[code:fixed-length-paths-1]{sursă}

Putem rezolva problema exact cu ideile expuse teoretic. Fiecare nod raportează la părintele său o listă cu numărul de noduri aflate la distanțe 0 (el însuși), 1 (fiii), 2 (nepoții) etc. Pentru a-și calcula lista, fiecare nod:

\begin{enumerate}
  \item Însumează listele primite de la toți fiii.
  \item Deplasează lista rezultată cu o poziție (fiul fiului meu este nepotul meu).
  \item Se adaugă pe sine însuși la distanță 0.
\end{enumerate}

Pentru implementare, putem folosi un deque, care oferă inserarea la început în $\bigoh(1)$. Pentru însumarea listelor, adăugăm mereu lista mai scurtă la cea mai lungă. În plus, fiecare nod $u$ răspunde la întrebarea: pentru cîte căi de lungime $k$ sînt eu LCA (nodul cel mai de sus de pe cale)? Apoi adaugă această valoare la un contor global. Pentru a calcula răspunsul, nodul $u$ confruntă lista primită de la fiecare fiu $v$ cu listele obținute și însumate anterior: dacă fiul $v$ raportează $a$ noduri la o distanță $l$ și fiii anteriori raportaseră $b$ noduri la o distanță $k-2-l$, adăugăm $a \cdot b$ la contorul global.

Care este complexitatea? Pare că ar fi $\bigoh(n \log n)$, după cum spuneam: cînd copiem un nod din lista $L_1$ în lista $L_2$, la final $L_2$ va stoca informații (frecvențe) despre cel puțin dublul numărului de noduri din $L_1$. Deci fiecare nod poate fi copiat de cel mult $\log n$ ori.

Dar putem da o limită și mai strînsă. Pentru această problemă soluția este, de fapt, $\bigoh(n)$! Programul nu operează cu noduri, ci doar cu distanțe. Cînd frecvența unei distanțe $d$ în $L_1$ este 2 sau mai mare, nu mai pierdem timp individual ca să copiem acele noduri din $L_1$ în $L_2$, ci le „copiem” pe toate simultan, însumînd niște frecvențe. Practic, fiecare nod este copiat o singură dată. Vă puteți convinge de asta adăugînd contoare globale în interiorul buclelor critice și verificînd că ele nu depășesc valoarea totală $n$.

Notă: pentru a interschimba două liste, folosiți întotdeauna metoda \ccode{swap()}, care doar schimbă pointeri între ei. Niciodată nu folosiți operatorul \ccode{=}, care face copieri de elemente și are complexitate $\bigoh(\text{lungime})$!

\subsection{Problema Distinct Colors (CSES) (din nou)}
\label{problem:distinct-colors-small-to-large}

\href{https://cses.fi/problemset/task/1139}{enunț}
$\bullet$
\hyperref[code:distinct-colors-small-to-large]{sursă}

Să reluăm această problemă și să o rezolvăm cu tehnica \textit{small-to-large}. O variantă ar fi ca fiecare nod să țină o listă sortată de culori. Atunci părintele trebuie să interclaseze listele fiilor. Dar nu putem face interclasarea în O(lista mai scurtă), ci doar în O(suma lungimilor). Aceasta duce la o soluție în $\bigoh(n^2)$. Exemplu: $n=1.000.000$, iar rădăcina are 1.000 de fii, fiecare cu cîte 1.000 de noduri în subarbore. Toate culorile sînt distincte. Atunci costul total al interclasărilor în rădăcină ar fi:

$$2.000 + 3.000 + \dots + 1.000.000$$

Ca să combinăm doi fii în O(fiul mai mic), putem menține culorile într-o tabelă hash (\ccode{unordered_set}). Atunci este ușor să „vărsăm” tabela mai mică în cea mai mare.

Două observații de implementare:

\begin{enumerate}
  \item Această variantă consumă mai mult spațiu pe stivă, căci are variabile locale mai mari. Pe calculatorul meu local, testele mari chiar umplu stiva!

  \item Această variantă este mai lentă decît cea cu AIB (nicio surpriză).
\end{enumerate}

\subsection{Problema Lomsat Gelral (Codeforces)}
\label{problem:lomsat-gelral}

\href{https://codeforces.com/contest/600/problem/E}{enunț}
$\bullet$
\hyperref[code:lomsat-gelral]{surse}

Folosim tehnica \textit{small-to-large}, așa cum se poate deduce și din numele problemei \emoji{fox}. Este important ca fiecare fiu să stocheze $\bigoh(\text{subarbore})$ informații, nu $\bigoh(n)$. Deci vom folosi o tabelă hash de culori cu frecvențele lor.

Ca observație interesantă, este mult mai eficient să calculați și să returnați din DFS tabela hash și celelalte informații, decît să le stocați în fiecare nod. Iată și o astfel de \href{https://codeforces.com/contest/600/submission/232610323}{implementare}, considerabil mai lentă.

Există și o soluție cu algoritmul lui Mo, puțin mai lentă, dar care consumă mai puțină memorie. Este necesară atenție la detalii. Ce informații stochează intervalul curent? Vă recomand să izolați acele structuri de date într-un \ccode{struct} sau o clasă separată.

Problemă similară: \href{https://kilonova.ro/problems/958}{Christmas Balls} (IIOT 2021/22 runda 2).

\subsection{Problema Tokens on a Tree (CodeChef)}
\label{problem:tokens-on-a-tree}

\href{https://www.codechef.com/problems/TRTOKENS}{enunț}
$\bullet$
\hyperref[code:tokens-on-a-tree]{surse}

O problemă echivalentă este \href{https://codeforces.com/contest/965/problem/E}{Short Code} (inspirată din viața reală, avînd în vedere cum își denumesc unii elevi variabilele).

Să demonstrăm teoretic ce avem de făcut. Iată diverse observații.

\textbf{Observația 1.} O monedă $A$ poate „sări” aparent peste altă monedă $B$: practic, monedele fiind identice, o urcăm pe $B$ pînă la destinația dorită, apoi pe $A$ în locul lui $B$.

\textbf{Observația 2.} În orice soluție, monedele se vor afla la vîrful arborelui. Niciodată nu vom avea o monedă sub un nod gol, căci am putea face o mutare în plus.

\textbf{Observația 3.} Dacă rădăcina conține inițial o monedă, atunci acea monedă nu pleacă nicăieri și nicio altă monedă nu îi va lua locul. Deci putem rezolva problema independent pentru subarbori.

\textbf{Observația 4.} Dacă rădăcina nu conține inițial o monedă, atunci dintr-unul dintre subarborii fiilor o monedă va urca în rădăcină. Restul fiilor vor fi rezolvați independent, conform Observației 3. Moneda care va urca în rădăcină este cea de adîncime maximă după ce rezolvăm fiii, ca să facem cît mai mulți pași în plus. Urcarea este aparentă, conform Observației 1.

Așadar, implementarea trebuie să combine în mod eficient fiii unui nod, apoi să găsească cea mai de jos monedă și să o urce în părinte. Am găsit două variante de implementare.

\subsubsection*{Implementare cu \textit{small-to-large}}

Fiecare nod $u$ calculează un vector/listă $f$ unde $f[i]$ pentru $i \geq 0$ este numărul de monede la distanță $i$ de $u$. Fiecare părinte însumează listele fiilor așa cum știm, iar algoritmul este $\bigoh(n)$, căci nodurile odată comasate își pierd identitatea. În plus, nodul $u$ se adaugă pe sine însuși la începutul listei și, dacă este loc, simulează urcarea unei monede transferînd o unitate de pe ultima poziție din $f$ pe prima.

\textbf{Detalii de implementare.} Implementarea cu \ccode{std::list} este cu vreo 25 de linii mai scurtă decît cea cu liste proprii, dar este de două ori mai lentă și consumă dublul memoriei. Implementarea cu \ccode{std::deque} este nefolosibilă ca timp și ca memorie (spre 1 GB). Probabil, clasa \ccode{deque} are costuri fixe, iar multe deque-uri mici sînt foarte scumpe.

\subsubsection*{Implementare cu liniarizare + RMQ}

Construim o liniarizare DFS și notăm, în nodurile care conțin monede, adîncimea acelor noduri. În nodurile care nu conțin monede nu notăm nimic. Pentru a găsi cea mai de jos monedă din subarborele unui nod $u$, găsim maximul pe intervalul subîntins de $u$. Pentru a muta moneda, scriem 0 în locul acelui maxim (moneda dispare) și scriem adîncimea lui $u$ la poziția nodului $u$ (moneda apare acolo). Apoi creștem numărul total de mutări cu diferența dintre cele două adîncimi. Avem nevoie de RMQ cu actualizare, deci putem folosi varianta pe arbori de segmente. Rezultă o complexitate de $\bigoh(n \log n)$. Codul este puțin mai lent și consumă mai multă memorie decît implementarea cu \textit{small-to-large}.

\subsection{Problema Blood Cousins Return (Codeforces)}
\label{problem:blood-cousins-return}

\href{https://codeforces.com/contest/246/problem/E}{enunț}
$\bullet$
\hyperref[code:blood-cousins-return]{surse}

Toate soluțiile încep prin a transforma numele în numere. Cea mai la îndemînă implementare folosește un \ccode{unordered_map}.

\subsubsection*{Implementarea cu \textit{small-to-large}}

O soluție destul de brutală cu \textit{small-to-large} este: fiecare nod $u$ ține un vector de set-uri, unde setul de pe poziția $i$ reține numerele distincte regăsite la adîncime $i$ (raportat la adîncimea lui $u$) în subarborele lui $u$. Cînd combinăm doi vectori, combinăm două cîte două seturile reprezentînd aceeași adîncime. Trebuie să avem grijă să folosim \textit{small-to-large} în două locuri:

\begin{enumerate}
  \item Copiem vectorul mai mic în cel mai mare.
  \item Pentru fiecare pereche de seturi, îl copiem pe cel mai mic în cel mai mare.
\end{enumerate}

Note de implementare:

\begin{enumerate}
  \item \ccode{unsorted_set} este mai lent decît \ccode{set}, deși algoritmic vorbind ne-ar trebui prima, care oferă timp constant. Dar tabelele hash (adică \ccode{unsorted_set}) au o mărime minimă dată de vectorul pe care se bazează.

  \item Reprezentarea listelor de adiacență cu \ccode{deque} este de două ori mai lentă decît cu \ccode{vector}.
\end{enumerate}

Implementarea este rezonabil de scurtă, dar nu prea eficientă.

\subsubsection*{Implementarea cu tehnici de bază}

Iată și o abordare care necesită doar parcurgeri, liniarizare și căutare binară. Soluția este greu de codat, dar este mai rapidă.

\begin{enumerate}
  \item Calculăm ordinea BFS. Atunci răspunsul la orice interogare se va traduce în numărarea elementelor distincte de pe un interval contiguu din BFS. Știm să facem asta folosind un simplu AIB și ordonînd interogările după capătul drept (vezi problema \hyperref[problem:dquery-fenwick]{D-query}).

  \item Pentru fiecare interogare, rămîne să aflăm primul și ultimul nod de la o anumită adîncime din subarborele lui $u$, ca să știm pe ce interval din BFS facem numărarea. Putem face asta cu două parcurgeri DFS și o stivă. La intrarea în fiecare nod, notăm valoarea sa pe stivă în dreptul adîncimii sale. La revenirea din nod, lăsăm stiva intactă. Atunci, la revenirea într-un nod $u$ aflat la adîncimea $d$, putem ști care este \textbf{ultimul} său descendent de la adîncimea $d'$: fie nu există, fie este nodul de la poziția $d'$ de pe stivă. Pentru a afla \textbf{primul} descendent de la adîncimea dorită, facem același DFS, dar iterînd prin fiii nodurilor în ordine inversă.
\end{enumerate}

Sună rezonabil din vorbe, dar \href{https://codeforces.com/contest/246/submission/294410845}{prima implementare} a fost migăloasă.

O soluție considerabil mai scurtă (cea inclusă în anexă) procedează astfel:

\begin{enumerate}
  \item Calculăm aceeași ordine BFS.

  \item Înlocuim fiecare interogare $\langle u, d \rangle$ cu interogarea $\langle depth[u] + d, t_{in}[u], t_{out}[u]\rangle$. Cu alte cuvinte, fiecare interogare interoghează un interval aflat la o anumită adîncime și cu noduri între timpii dați. Sortăm și procesăm interogările cu un AIB ca de obicei.
\end{enumerate}

O a treia implementare este: colectăm nodurile separat pe fiecare nivel, în ordinea timpilor de vizitare (care este chiar ordinea DFS). Acum intervalul de interes pentru o interogare referitoare la nodul $u$ este pe un nivel cunoscut și este delimitat de timpii de intrare și de ieșire din $u$.

Este greu să construim cîte un AIB pe fiecare nivel, dar putem folosi un \ccode{set} cu aceeași informație: pozițiile ultimelor apariții ale fiecărui element distinct. Iată \href{https://codeforces.com/contest/246/submission/300415656}{o implementare} curată a fostului olimpic Alex Nuță.
