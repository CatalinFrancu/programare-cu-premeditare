\section{Probleme}

\subsection{Problema Gold Transfer (Codeforces)}
\label{problem:gold-transfer}

\href{https://codeforces.com/contest/1535/problem/E}{enunț}
$\bullet$
\hyperref[code:gold-transfer]{sursă}

Atenție mare la garanția din enunț: $c_i > c_{p_i}$. Cu alte cuvinte, pentru orice operație de cumpărare trebuie să pornim din rădăcină spre nodul $u$ și să cumpărăm orice cantități disponibile, pînă satisfacem cererea.

Cu timpul, nodurile de la rădăcină se vor goli, deci pare o idee bună să găsim rapid cel mai de jos strămoș care încă are aur disponibil. Dacă reușim să-l găsim în $\bigoh(f(n))$ (intenția problemei fiind $f(n) = \log n$), atunci complexitatea globală va fi $\bigoh(q \cdot f(n) + n)$. De ce? Din acel strămoș putem parcurge lanțul în jos pas cu pas, cumpărînd tot aurul disponibil, pînă satisfacem cererea. Fiecare nod poate fi golit cel mult o dată, iar ultimul nod din fiecare interogare poate păstra niște aur. De aceea, efortul total pentru parcurgerea lanțurilor este $\bigoh(n + q)$.

\subsubsection*{Detalii de implementare}

Arborele este dinamic, deci nu putem construi o liniarizare.

Am ales să accelerez urcarea în arbore cu \textit{binary lifting} cu doi pointeri, dar orice altă metodă este acceptabilă.

Odată ce golim un nod, avem nevoie să coborîm în fiul său care duce spre nodul original. Am ales să  fac acest lucru cu o stivă, dar soluția este cam lentă (2x față de altele).

Întrucît nu avem de ce să parcurgem toți fiii unui nod, nu avem nevoie de liste de adiacență, ci doar de pointeri la părinte.

\subsection{Problema A and B and Lecture Rooms (Codeforces)}
\label{problem:a-and-b-and-lecture-rooms}

\href{https://codeforces.com/contest/519/problem/E}{enunț}
$\bullet$
\hyperref[code:a-and-b-and-lecture-rooms]{sursă}

Problema cere să răspundem la $m$ întrebări de forma: Date fiind nodurile $u$ și $v$ (posibil egale), cîte noduri din arbore se află la distanță egală de $u$ și de $v$?

Pentru soluția teoretică, următoarea vizualizare este utilă. Să „atîrnăm” arborele de nodurile $u$ și $v$, ca pe o ghirlandă bine întinsă.  Atunci calea cea mai scurtă $u-v$ va fi orizontală, iar de lanțurile de pe cale vor atîrna restul subarborilor.

Dacă distanța $u-v$ este impară, atunci răspunsul este 0. Dacă distanța este pară, atunci fie $w$ nodul de la jumătatea distanței. Nodurile aflate la distanță egală de $u$ și de $v$ vor fi $w$ și orice nod din subarborii care atîrnă din $w$.

În practică vom alege o rădăcină și vom precalcula informații pentru LCA. Apoi, eu am redus problema la următoarele cazuri (poate se poate și mai simplu):

\begin{enumerate}
  \item Dacă distanța $u-v$ este impară, răspunsul este 0.

  \item Dacă $u=v$, răspunsul este $n$.

  \item Dacă $u$ și $v$ au adîncimi egale, atunci răspunsul este: mărimea subarborelui lui $LCA(u,v)$ minus mărimile subarborilor fiilor lui $LCA(u,v)$ care pornesc către $u$, respectiv către $v$.

  \item Altfel, să presupunem că $u$ are adîncime mai mare decît $v$. Atunci nodul $w$ este undeva mai jos de LCA, mergînd către $u$. Răspunsul este: mărimea subarborelui lui $w$ minus mărimea subarborelui fiului lui $w$ care pornește către $u$.
\end{enumerate}

\subsubsection*{Detalii de implementare}

Punctul (4) presupune să calculăm al $k$-lea strămoș. De exemplu, dacă adîncimile sînt $d[u]=50$, $d[v]=20$ și $d[LCA]=10$, atunci distanța $u-v$ este $40+10=50$, jumătatea distanței este $25$, iar nodul $w$ este al $25$-lea strămoș al lui $u$.

De aceea, metoda lui Tarjan nu ne prea ajută, ci avem nevoie de o metodă cu \textit{jump pointers}.

La punctele (3) și (4), pentru a afla „fiul lui $w$ care pornește către $u$”, putem refolosi informațiile pentru al $k$-lea strămoș. Dacă notăm cu $k$ diferența pe înălțime între $w$ și $u$, atunci răspunsul este al $k-1$-lea strămoș al lui $u$.

La arbori, multe informații sînt redundante și putem stoca doar o submulțime. Exemple:

\begin{itemize}
  \item Mărimea subarborelui lui $u$ nu trebuie stocată implicit dacă cunoaștem timpii DFS, ci poate fi calculată ca $t_o[u]-t_i[u]+1$.

  \item Paritatea distanței poate fi calculată fără a calcula distanța efectivă. Calculăm doar suma adîncimilor.

  \item Al $k$-lea strămoș al unui nod poate fi găsit ca strămoșul de la adîncimea $d[u]-k$ al unui nod, dacă cunoaștem adîncimile nodurilor.
\end{itemize}

\subsection{Problema Company (Codeforces)}
\label{problem:company}

\href{https://codeforces.com/contest/1062/problem/E}{enunț}
$\bullet$
\hyperref[code:company]{sursă}

Problema poate fi rezumată astfel: dintre toate nodurile cu numere de la $l$ la $r$, cum putem elimina un nod astfel încît LCA-ul celor rămase să aibă o adîncime cît mai mare, raportată la rădăcină?

Întrebarea teoretică la care trebuie să răspundem este: care este LCA-ul unei submulțimi de noduri? Observăm că nu este nevoie să iterăm prin toate, ci este suficient să calculăm LCA-ul între primul și ultimul nod în ordinea descoperirii lor în DFS. De aceea, ca să încercăm să coborîm LCA-ul, trebuie să eliminăm unul dintre aceste noduri. Altfel LCA-ul submulțimii după eliminarea unui nod va rămîne nemodificat față de LCA-ul original.

Să presupunem că găsim aceste noduri, fie ele $x$ și $y$. Încercăm să îl eliminăm pe $x$ și să calculăm LCA-ul submulțimii $[l,x-1] \cup [x+1,r]$. Apoi îl eliminăm pe $y$ și calculăm LCA-ul submulțimii $[l,y-1] \cup [y+1,r]$. Afișăm varianta care duce la un LCA de adîncime maximă.

\subsubsection*{Detalii de implementare}

Ca să găsim timpii DFS minim/maxim ai nodurilor din intervalul $[l,r]$, putem construi un vector $t[]$ unde $t[u]$ este timpul vizitării nodului $u$. Astfel reducem subproblema la una de RMQ. Pentru a deduce, din acești timpi, nodul efectiv (primul nod vizitat dintre toate din $[l,r]$) este suficient un vector $inv[]$ unde $inv[i]$ este nodul vizitat la momentul $i$. Practic $t$ și $inv$ sînt permutări inverse.

Pentru intervalele la care ajungem după eliminarea lui $x$ și $y$ (respectiv $[l,x-1]$, $[x+1,r]$ și celelalte) avem nevoie să aflăm LCA-ul, deci avem nevoie tot de RMQ ca să aflăm primul și ultimul nod în ordinea DFS. Dar am făcut următoarea observație care reduce mult numărul de interogări.

Fie $a,b,c,d$ primul, al doilea, penultimul și respectiv ultimul nod din intervalul $[l,r]$, în ordinea DFS. Atunci iau naștere două cazuri:

\begin{itemize}
  \item Dacă îl eliminăm pe $a$, LCA-ul nodurilor rămase este $LCA(b,d)$.
  \item Dacă îl eliminăm pe $d$, LCA-ul nodurilor rămase este $LCA(a,c)$.
\end{itemize}

De aceea, am proiectat o structură de date care să returneze, pentru o interogare $[l,r]$, primele două minime și primele două maxime din intervalul $[l,r]$. Practic structura returnează exact cele patru valori $a,b,c,d$.

Putem folosi RMQ cu sparse table, cu atenție la detalii la calculul celui de-al doilea maxim/minim (intervalele de lungime putere a lui 2 pot fi suprapuse). Dar nu-mi place ideea de a consuma memorie $\mathcal{O}(n \log n)$ fără rost. \emoji{neutral-face} De aceea, am implementat structura ca pe un arbore de intervale. Operația critică este combinarea a două tupluri $(a', b', c', d')$ și $(a'', b'', c'', d'')$. Implementarea este relativ ușoară:

\begin{itemize}
  \item Dacă $a' < a''$ atunci primul minim este $a'$, iar al doilea minim este $\min(b', a'')$.
  \item Dacă $a' \geq a''$ atunci primul minim este $a''$, iar al doilea minim este $\min(b'', a')$.
  \item Similar pentru maxime.
\end{itemize}

Sursa mea este printre cele mai rapide, cu excepția celor care parsează intrarea. Suspectez că ajută mult (1) economia de memorie și (2) calculul simultan al minimelor și al maximelor, în aceeași structură de date.

\subsection{Problema Duff in the Army (Codeforces)}
\label{problem:duff-in-the-army}

\href{https://codeforces.com/contest/587/problem/C}{enunț}
$\bullet$
\hyperref[code:duff-in-the-army]{sursă}
$\bullet$
\href{https://www.youtube.com/watch?v=EIxsPBbZ_b8}{coloană sonoră} \emoji{slightly-smiling-face}

Rezumat: Se dă un arbore cu $n$ noduri și $m$ locuitori. Locuitorul $i$ locuiește în orașul $c_i$. Răspundeți la $q$ interogări de forma $(u, v, a)$ cu semnificația: tipăriți primii $a$ locuitori, ordonați după ID, care locuiesc pe calea $(u, v)$. Notă: $a \leq 10$.

Problema se duce tot în direcția aflării LCA. Dacă $LCA(u,v)=w$, și dacă aflăm populațiile pe căile $(u, w)$ și $(v, w)$, putem să le interclasăm în $\bigoh(a)$ și să păstrăm cele mai mici $a$ valori.

Cum aflăm populația pe o cale? Nu văd o soluție în $\bigoh(a + \log n)$, dar $\bigoh(a \log n)$ este facilă. Orice algoritm de LCA ne oferă această complexitate dacă precalculăm, împreună cu pointerii în sus, și populația acoperită de acei pointeri. De exemplu, cu metoda \textit{binary lifting}, fiecare din pointerii peste 1, 2, 4, 8, ... niveluri rețin și primii $a$ membri ai populației de pe acea cale. Populația pe calea de lungime 16 se obține interclasînd cele două populații pe căile de lungime 8 și păstrînd cel mult 10 minime.

Atenție la metoda folosită! \textit{Binary lifting} cu memorie $\bigoh(n \log n)$ va necesita $\np{100000} \times 18 \times 10$ întregi, adică 72 MB în plus. Este fezabil, dar este de evitat. Implementarea mea este printre cele mai rapide și nu face nimic deosebit, doar folosește \textit{binary lifting} cu doi pointeri. Economia de memorie înseamnă economie de timp.

Ne întîlnim, din nou, cu o situație care cere să particularizați structurile de date, nu doar să le pictați. Un alt exemplu de astfel de problemă este: să se preproceseze un arbore astfel încît să putem răspunde eficient la interogări de forma $(u,v)$ = maximul pe calea $u-v$. Și aici putem face fiecare \textit{jump pointer} să rețină maximul pe calea subîntinsă. Problema are și soluții mai eficiente, dar aceasta este relativ elementară.
