\section{Probleme}

\subsection{Problema Tree Queries (Codeforces)}
\label{problem:tree-queries}

\href{https://codeforces.com/contest/1328/problem/E}{enunț}
$\bullet$
\hyperref[code:tree-queries]{sursă}

Probabil am putea implementa următoarea soluție. Pentru fiecare interogare, pornim din cel mai de jos dintre noduri, mergînd pînă la rădăcină, și vedem dacă întîlnim toate celelalte noduri sau părinții acestora. Dar această soluție necesită $\mathcal{O}(n)$ per interogare pentru un arbore degenerat. Probabil ea poate fi adusă la $\mathcal{O}(\sqrt{n})$ sau $\mathcal{O}(\log n)$ prin tehnici mai complicate.

În loc de acesta, să procedăm astfel. Fie $u$ cel mai de jos nod dintr-o interogare. Atunci toate celelalte noduri \textbf{sau} părinții lor trebuie să se afle pe calea de la $u$ la rădăcină. Cu alte cuvinte, să fie strămoși ai lui $u$. Mai mult, decizia se simplifică astfel: dacă un nod $v$ este pe calea de la $u$ la rădăcină, atunci și părintele lui $v$ se va afla pe calea de la $u$ la rădăcină. Deci este suficient să testăm doar părinții și să răspundem la întrebarea: Sînt părinții tuturor nodurilor dintr-o interogare strămoși ai celui mai de jos nod? (Complicația cu noduri și părinți este mai mult un \textit{red herring}, o diversiune care poate păcăli pe cineva.)

Vom folosi testul de strămoș studiat anterior: $v$ este strămoș al lui $u$ dacă și numai dacă $t_i[v] < t_i[u] < t_o[u] < t_o[v]$.

\subsubsection*{Detalii de implementare}

Am preferat să declar variabila \ccode{time} statică, în interiorul funcției \ccode{euler_tour}, ca să evidențiez că nu este folosită altundeva.

Nodurile dintr-o interogare nu trebuie stocate, sortate etc. Nu avem nevoie de adîncimea nodurilor. Pur și simplu îl reținem pe cel mai de jos găsit pînă atunci, fie el $l$. Cînd citim un nod nou, $u$, îi aflăm părintele $p$. Pot lua naștere trei cazuri:

\begin{itemize}
  \item Dacă $p$ este strămoș al lui $l$, atunci $l$ nu se modifică, iar calea care conține toate nodurile de pînă acum rămîne calea de la $l$ la rădăcină.
  \item Dacă $l$ este strămoș al lui $p$, atunci $p$ îl înlocuiește pe $l$, iar calea care conține toate nodurile de pînă acum este calea de la $p$ la rădăcină.
  \item Altfel nu există nicio cale care să le conțină pe $l$ și pe $p$, deci răspunsul la interogarea curentă este \texttt{NO}.
\end{itemize}

\subsection{Problema Subtree Queries (CSES)}
\label{problem:subtree-queries}

\href{https://cses.fi/problemset/task/1137}{enunț}
$\bullet$
\hyperref[code:subtree-queries]{sursă}

Această problemă este o aplicație directă a liniarizării. Facem o liniarizare de tip DFS pentru a calcula doar vectorul $t_i$ (timpul de intrare în fiecare nod). Apoi construim un vector indexat după timp, în care notăm valoarea fiecărui nod $u$ la poziția $t_i[u]$. Peste acest vector construim un simplu arbore Fenwick sau orice structură preferați care să ofere actualizare punctuală + sumă pe interval.

O altă variantă clasică a acestei probleme ar fi ca operațiile de actualizare să fie pe subarbore: atribuie tuturor nodurilor din subarborele lui $u$ o valoare $x$, incrementează toate nodurile cu o cantitate $x$ etc. Desigur, aceste operații s-ar traduce în operații de actualizare pe interval, pentru care putem folosi un arbore de intervale cu propagare \textit{lazy}.

\subsection{Problema Path Queries (CSES)}
\label{problem:path-queries}

\href{https://cses.fi/problemset/task/1138}{enunț}
$\bullet$
\hyperref[code:path-queries]{sursă}

Această problemă ne arată utilitatea liniarizării Euler. Să considerăm momentul în care DFS-ul intră în nodul $u$, adică $t_i[u]$. El corespunde prefixului din liniarizare de la poziția 1 pînă la poziția $t_i[u]$. Observăm că:

\begin{enumerate}
  \item Nodurile complet vizitate înainte de intrarea în $u$ (numite și \textit{noduri negre}) apar de cîte două ori.
  \item Nodurile în curs de vizitare (calea de la $u$ la rădăcină, numite și \textit{noduri gri}) apar cîte o dată.
  \item Nodurile încă nevizitate (numite și \textit{noduri albe}) nu apar niciodată.
\end{enumerate}

Putem exprima punctul (2) și în termeni de strămoși, discutați anterior: strămoșii lui $u$ sînt singurele noduri ale căror intervale cuprind intervalul lui $u$.

De aici rezultă cum putem folosi paritatea aparițiilor ca să notăm informații de pe calea spre rădăcină. Notăm valoarea fiecărui nod $v$ cu semnul + la poziția $t_i[v]$ și cu semnul - la poziția $t_o[v]$. Astfel, suma prefixului $[1, t_i[u]]$ va fi exact suma valorilor pe calea de la $u$ la rădăcină.

\subsection{Problema New Year Tree (Codeforces)}
\label{problem:new-year-tree}

\href{https://codeforces.com/contest/620/problem/E}{enunț}
$\bullet$
\hyperref[code:new-year-tree]{sursă}

Problema este relativ directă, doar cu puțin mai complicată decît precedentele. După liniarizare, avem nevoie de o structură de date care să admită operațiile:

\begin{enumerate}
  \item \ccode{range_set(l, r, val)}: scrie valoarea val pe tot intervalul $[l,r]$
  \item \ccode{range_count_distinct(l, r)}: returnează numărul de valori distincte din intervalul $[l,r]$.
\end{enumerate}

Problema numărării de elemente distincte cu actualizări nu este trivială, dar varianta de față are un avantaj: valorile sînt între 1 și 60, deci putem folosi măști de biți. Rezultă că avem nevoie de un arbore de intervale cu propagare lazy, cu operațiile:

\begin{enumerate}
  \item atribuiri pe interval;
  \item OR pe biți pe interval.
\end{enumerate}

\subsection{Problema Max Flow (USACO)}
\label{problem:max-flow}

\href{https://usaco.org/index.php?page=viewproblem2\&cpid=576}{enunț}
$\bullet$
\hyperref[code:max-flow]{surse}

\subsubsection*{Metoda 1: Vectori de diferențe pe arbore}

O primă soluție aduce cu vectori de diferențe („șmenul lui Mars”), dar în varianta arborescentă. Pentru fiecare nod dorim să calculăm numărul de căi care trec prin acel nod. Atunci, pentru fiecare cale $(u, v)$, dorim să incrementăm valorile tuturor nodurilor de pe cale. Fie $w$ cel mai de jos strămoș comun (LCA) al perechii $(u, v)$. Atunci dorim, echivalent,

\begin{itemize}
  \item Să incrementăm toate valorile de la $u$ la rădăcină.
  \item Să incrementăm toate valorile de la $v$ la rădăcină.
  \item Să scădem cu 1 valoarea lui $w$ (care a fost incrementat de două ori).
  \item Să scădem cu 2 valorile de la părintele lui $w$ la rădăcină.
\end{itemize}

Putem face asta adunînd $\pm 1$ în nodurile respective, apoi propagînd în sus acele valori. Implementarea este lungă întrucît trebuie să calculeze LCA și am ales să fac asta cu algoritmul lui Tarjan, cel mai eficient în situația offline (vom detalia în viitorul apropiat).

\subsubsection*{Metoda 2: AIB peste liniarizare}

La momentul vizitării nodului $u$, putem împărți arborele în 3 zone disjuncte:

\begin{enumerate}
  \item Zona 1 este porțiunea vizitată înainte de $u$.
  \item Zona 2 este subarborele lui $u$.
  \item Zona 3 este porțiunea care va fi vizitată după revenirea din $u$.
\end{enumerate}

Atunci, căile care trec printr-un nod $u$ sînt de trei feluri:

\begin{enumerate}
  \item Cele care încep în zona 1 și se termină în zona 2.
  \item Cele care încep în $u$, indiferent dacă se termină în zona 2 sau în zona 3.
  \item Cele care pornesc dintr-un descendent al lui $u$ și trec prin $u$, fie că se termină în alt descendent al lui $u$, fie în zona 3.
\end{enumerate}

Pentru a afla aceste informații pentru fiecare nod, facem întîi o liniarizare de tip DFS imediat ce citim arborele. Reamintim că subarborele fiecărui nod ocupă un interval contiguu în această liniarizare.

Abia acum citim restul datelor (căile). Pentru fiecare nod $u$ colectăm lista de căi care încep din $u$ și lista de căi care se termină în $u$. Mai exact, pentru fiecare cale $(u,v)$, cunoscînd liniarizarea, ne asigurăm că $t_i[u] < t_i[v]$ (le interschimbăm la nevoie). Apoi adăugăm $v$ la lista de căi care pornesc din $u$ și $u$ la lista de căi care se termină în $v$.

Acum putem rula o a doua parcurgere DFS în care ținem evidența căilor active. La intrarea într-un nod marcăm ca active căile care pornesc din $u$. La ieșire, marcăm ca inactive căile care se termină în $u$ (adică le ștergem din evidență).

Care este structura necesară pentru această evidență? De exemplu, pentru întrebarea (1) de mai sus avem nevoie să știm ce căi active se termină în zona 2. Putem folosi un arbore Fenwick peste liniarizare în care notăm +1 la momentul nodului de sfîrșit al căilor active. Atunci răspunsul la (1) este suma pe $[t_i[u], t_o[u]]$.

Pentru (2) răspunsul este pur și simplu lungimea listei de căi care încep în $u$.

Pentru (3), la revenirea dintr-un fiu $v$ avem nevoie să știm ce căi active au început în subarborele lui $v$. De aceea, vom folosi un al doilea arbore Fenwick în care notăm +1 la momentul nodului de început al căilor active.

Această metodă nu mai necesită calculul LCA.

\subsubsection*{Metoda 3 (cred): \textit{Small to large}}

Cred că fiecare nod își poate menține colecția de căi care trec prin el. Un părinte va unifica aceste colecții, eliminîndu-le pe cele care apar de două ori (pentru care părintele este LCA). Dacă folosim cea mai mare colecție dintre cele ale fiilor, timpul rezultat va fi $\mathcal{O}(n + q \log q)$.
