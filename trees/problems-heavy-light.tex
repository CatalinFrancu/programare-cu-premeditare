\section{Probleme}

\subsection{Problema Heavy Path Decomposition (Infoarena)}
\label{problem:heavy-path-decomposition}

\href{https://www.infoarena.ro/problema/heavypath}{enunț}
$\bullet$
\hyperref[code:heavy-path-decomposition]{surse}

Aceasta este exact problema studiată la teorie. Vom citi codul.

Prima versiune este cea „canonică”. A doua versiune face o optimizare minoră care elimină nevoia calculării înălțimii nodurilor. Ea pornește de la următoarea observație. Dorim ca, odată ce $u$ ajunge pe lanțul comun, să se oprească din urcat și să-l aștepte și pe $v$ (pe acel lanț comun vom face ultima interogare). Dar, dacă $u$ a ajuns pe lanțul comun, iar $v$ încă nu, atunci în mod necesar $t_{in}[u] < t_{in}[v]$, căci toate nodurile de pe acel lanț sînt vizitate primele în DFS, fiind noduri heavy. Așadar, este suficient să comparăm timpii DFS ai lui $u$ și $v$.

Subliniem că în funcția \ccode{query} parcurgem mereu lanțul al cărui capăt de sus are adîncime mai mare. De ce nu comparăm pur și simplu înălțimile lui $u$ și $v$? Dați un contraexemplu!

O problemă echivalentă este \href{https://cses.fi/problemset/task/2134}{Path Queries II} (CSES).

\subsection{Problema Disruption (USACO)}
\label{problem:disruption}

\href{https://usaco.org/index.php?page=viewproblem2\&cpid=842}{enunț}
$\bullet$
\hyperref[code:disruption]{surse}

Vom discuta trei soluții, de amorul artei.

\subsubsection*{Soluția cu HLD}

Să considerăm o cale de înlocuire $(u,v)$. Căror muchii le poate ea suplini dispariția? Doar celor de pe calea $u-v$ din arbore. Așadar, o soluție teoretică este: pentru fiecare cale de înlocuire $(u,v)$ de cost $c$, notifică toate muchiile de pe calea $u-v$ că au la dispoziție o înlocuire de cost $c$. După procesarea tuturor căilor, pentru fiecare muchie tipărește costul minim despre care a fost notificată, sau -1 dacă muchia nu a primit notificări.

Concret, ce înseamnă aceste notificări? Fie $l = LCA(u,v)$. Atunci vrem să marcăm costul $c$ pe căile $u-l$ și $v-l$. De aici ne poate veni ideea descompunerii \textit{heavy-light}, care garantează că o cale de înlocuire va genera cel mult $\bigoh(\log n)$ intervale de actualizat.

Ce structură folosim? Pe fiecare lanț avem nevoie de operațiile:

\begin{enumerate}
  \item \ccode{range_set(l, r, c)}: pe fiecare poziție $l \leq i \leq r$, atribuie $v[i] = \min(v[i], c)$.
  \item \ccode{query(i)}: returnează $v[i]$.
\end{enumerate}

Desigur, \ccode{range_set} va descompune $[l,r]$ în niște intervale și va scrie valoarea $c$ pe acele intervale. Cum procedăm după aceasta? Nu vă repeziți la implementarea cu propagare \textit{lazy}! Interogările sînt punctuale, nu pe interval, deci este suficient să vizităm toți strămoșii unui nod (din aint) și să returnăm minimul valorilor găsite. Mai mult, toate interogările vor veni după toate actualizările. Deci putem face o singură propagare top-down la sfîrșitul actualizărilor. Atunci în fiecare frunză din aint vom avea exact răspunsul dorit.

Mai sînt două mici goluri de umplut:

\begin{enumerate}
  \item Arborele de intervale trebuie inițializat cu $\infty$.

  \item Conceptual, problema cere informații despre muchii. Dar, datorită DFS-ului, fiecare muchie unește un fiu de părintele său. Vom stoca informațiile în fiu.
\end{enumerate}

\subsubsection*{Soluția cu \textit{small-to-large}}

Soluția oficială pornește de la altă observație teoretică. Orice muchie $(u,v)$ poate fi înlocuită de o cale de înlocuire $(x,y)$ cu proprietatea că $x$ și $y$ se află de părți diferite ale muchiei $(u,v)$. Formulată în termeni de DFS, condiția este: muchia de la orice nod $u$ la părintele său poate fi înlocuită de orice cale de înlocuire $(x,y)$ care are \textbf{exact} un capăt în subarborele lui $u$. Să denumim o astfel de cale de înlocuire \textbf{viabilă pentru $u$}.

Așadar, dorim ca fiecare nod $u$ să-și calculeze mulțimea de căi viabile și să o raporteze pe cea de cost minim. Atunci mulțimea unui nod $u$ provine din:

\begin{enumerate}
  \item reuniunea mulțimilor fiilor,

  \item plus căile care au un capăt chiar în $u$,

  \item minus căile care apar de două ori în (1) și (2), deoarece o cale care începe și se termină în subarborele lui $u$ nu este viabilă pentru $u$.
\end{enumerate}

Putem folosi tehnica \textit{small-to-large} pentru a garanta că fiecare element este transferat între mulțimi de cel mult $\log m$ ori. Mulțimile însăși trebuie să poată raporta valoarea minimă, deci vor avea un cost logaritmic (de exemplu, cu \ccode{std::set}). Complexitatea totală este $\bigoh(n \log m + m \log^2 m)$.

Puteți găsi o implementare foarte concisă (dar cam lentă) \href{https://starcoder.org/video/usacovideo-usaco-2018-platinum-open-p3/}{aici}. Ea stochează în seturi perechi $(cost, id)$: costul unei căi servește la găsirea costului minim, iar ID-ul servește la găsirea duplicatelor, pentru eliminarea lor. Eu am ales o modalitate diferită: am sortat căile de înlocuire după cost, astfel încît ID-urile mai mici să corespundă la costuri mai mici.

Iată încă un detaliu de folosire a \ccode{set}-urilor. O implementare naivă va insera sau șterge căi cu următorul cod:

\begin{minted}{c}
if (s.count(id)) {
  s.erase(id);
} else {
  s.insert(id);
}
\end{minted}

Totuși, acest cod face două căutări per operație: una pentru găsirea elementului și a doua pentru inserare sau ștergere, după caz. Dar se poate și cu o singură căutare! Funcția \href{https://en.cppreference.com/w/cpp/container/set/insert}{insert}, dacă eșuează, returnează un iterator la elementul care a cauzat eșecul.

\begin{minted}{c}
std::pair<set::iterator, bool> p = s.insert(id);
if (!p.second) {
  // Inserarea a eșuat, iar p.first pointează chiar la elementul-duplicat.
  s.erase(p.first);
}
\end{minted}

\subsubsection*{Soluția cu DFS exclusiv}

Dacă vă amintiți, la problema \hyperref[problem:tree-and-queries]{Tree and Queries} am discutat un DFS special care folosește o singură structură de date globală. DFS-ul garantează că fiecare nod $u$ va avea acces, la un moment dat în timp, la structura de date care conține informații doar despre subarborele lui $u$.

Putem folosi acest algoritm și aici. Avem nevoie să includem/excludem noduri din structură, ceea ce presupune să includem/excludem căile care au un capăt în acele noduri. Așadar, avem nevoie de o structură de date cu operațiile:

\begin{enumerate}
  \item Activează/dezactivează o poziție.
  \item Returnează poziția minimă activă (sau o valoare specială dacă nu există poziții active).
\end{enumerate}

Un AIB este suficient, cu căutare binară pentru (2). Ce complexitate are această soluție?

\subsubsection*{Benchmarks}

Testele sînt mici, deci nu prea concludente, dar iată rezultatele:

\begin{itemize}
  \item Cu descompunere \textit{heavy-light}: 30 ms, 7 MB.
  \item Cu \textit{small-to-large}: 74 ms, 18 MB.
  \item Cu \textit{small-to-large} exclusiv: 55 ms, 12 MB.
\end{itemize}

\subsection{Problema Rafaela (Lot 2014)}
\label{problem:rafaela}

\href{https://kilonova.ro/problems/1979}{enunț}
$\bullet$
\hyperref[code:rafaela]{surse}

Ca observație preliminară, interogările pot fi reformulate astfel: dacă aș înrădăcina arborele în nodul $u$, care este populația maximă a unui subarbore al rădăcinii?

În practică vom fixa rădăcina în nodul 1. Fie $S(u)$ populația subarborelui nodului $u$. Iau naștere două cazuri:

\begin{enumerate}
  \item Răspunsul la interogare este $S(1) - S(u)$ dacă populația maximă sosește pe muchia de la $u$ la părinte. Desigur, $S(1)$ este populația întregului arbore, care este trivial de întreținut.
  \item Răspunsul la interogare este $\max S(v)$, unde $v$ este un fiu al lui $u$.
\end{enumerate}

\subsubsection*{Soluție doar cu arbore de intervale}

Pare natural să încercăm să menținem $S(u)$ pentru toate nodurile. Cînd populația lui $u$ se modifică cu $\Delta$, toți strămoșii lui $u$ cîștigă $\Delta$ populație, deci parcurgem toate lanțurile de la $u$ la rădăcină și adăugăm $\Delta$ pe prefixele corespunzătoare ale acestor lanțuri.

Cum stabilim maximul pentru cazul (2) de mai sus? Este nevoie de puțin spirit de observație. Dacă insistăm să interogăm doar fiii lui $u$, aceștia sînt dispersați prin liniarizare. Dar este suficient să interogăm \textbf{tot subarborele} lui $u$, fără $u$ însuși. Nu avem cum să greșim, căci, dacă maximul s-ar afla într-un nepot sau strănepot al lui $u$, cu atît mai mult fiul din care provine acel nepot sau strănepot ar avea populație și mai mare. Așadar, aflăm subarborele maxim cu o interogare pe intervalul $[t_{in}[u] + 1, t_{out}[u]]$.

Implementarea necesită doar un arbore de intervale cu adăugare pe interval și maxim pe interval.

\subsubsection*{Soluție cu arbore de intervale + caz separat pentru fiul greu}

Nu-mi place să dau doar soluții de idee. Pentru aceea există matematica. \emoji{beaming-face-with-smiling-eyes} Iată și o soluție mai muncitorească.

Din nou, la actualizarea unui nod facem operații de adăugare pe interval pe toate lanțurile. Acum diferențiem cazul (2) în două subcazuri: Subarborele cu populație maximă îl are fiul greu sau unul dintre fiii ușori. Ca să evităm confuzia, reamintesc că fiul greu este ales după numărul de noduri, care nu are neapărat și populația maximă.

Fiul greu îl putem interoga în $\bigoh(\log n)$. Putem chiar să folosim doar un arbore Fenwick (AIB) cu actualizare pe interval și interogare punctuală.

Nu ne permitem să interogăm toți fiii ușori, dar este suficient să-l aflăm eficient pe cel mai populat. Cel mai „ciobănește”, fiecare nod poate menține un \ccode{std::multiset} cu mărimile subarborilor ușori (așadar nu și mărimea subarborelui greu). Atunci pentru a răspunde la interogări comparăm trei valori:

\begin{enumerate}
  \item Părintele (populația totală minus populația nodului însuși).
  \item Fiul greu.
  \item Fiul ușor (maximul din \ccode{multiset}).
\end{enumerate}

Ce implică actualizările în această structură? Partea frumoasă este că \textbf{nu} trebuie să actualizăm seturile nodurilor de pe fiecare lanț vizitat, căci acele lanțuri constau, prin definiție, din muchii grele. Trebuie actualizate doar nodurile-părinte ale fiecărui lanț, căci doar acele muchii sînt ușoare.

De amorul artei, putem folosi și o structură mai elegantă decît seturile STL. O parcurgere BFS este suficientă, căci în acea parcurgere fiii fiecărui nod devin vecini. Așadar, ne este suficient un arbore de intervale peste parcurgerea BFS, cu actualizare punctuală și interogare de maxim pe interval. Iată \href{https://kilonova.ro/submissions/515909}{o implementare}.

Am observat că testele nu pedepsesc iterarea naivă prin fiii ușori. Am trimis și \href{https://kilonova.ro/submissions/515914}{o ultimă sursă} care ia 100p astfel.

\subsubsection*{Soluție cu descompunere în radical}

Includ și această soluție pentru familiarizarea cu astfel de alternative la HLD. Ea obține 70 de puncte.

Procesăm operațiile în blocuri de mărime circa $\sqrt{q}$. La începutul fiecărui bloc facem un DFS ca să calculăm $S(u)$ pentru toate nodurile. Acum, pentru o interogare în nodul $u$, am dori să luăm maximul dintre valorile pentru fiii lui $u$ ai căror arbori nu au suferit modificări (valori pe care le știm deja) și valorile fiilor modificați, aduse la zi. Similar, exteriorul subarborelui lui $u$ poate să fi suferit modificări.

Dacă avem 10 interogări într-un singur nod $u$, pe permitem să consultăm toți fiii lui $u$ \textbf{o singură dată}. Asta face, de exemplu, DFS-ul, al cărui efort total este $\bigoh(n)$. Nu ne permitem să iterăm prin toți fiii lui $u$ pentru fiecare interogare, căci ajungem la $\bigoh(q·n)$, de exemplu pentru un arbore-stea cu toate interogările în centrul arborelui.

Observațiile-cheie sînt că există interogări despre cel mult $\sqrt{q}$ noduri, iar pentru fiecare nod $u$ cel mult $\sqrt{q}$ dintre subarborii lui $u$ au modificări.

Restul nu este trivial, dar sînt doar detalii de implementare care urmăresc să obțină:

\begin{enumerate}
  \item Efort $\bigoh(n)$ la începutul blocului.

  \item Vizitarea fiilor nemodificați ai lui $u$ o singură dată per bloc $\to$ efort total $\bigoh(n)$ per bloc.

  \item Vizitarea fiilor modificați o dată per interogare $\to$ efort $\bigoh(\sqrt{q})$ per interogare.
\end{enumerate}

Dacă facem asta, obținem complexitatea totală $\bigoh((n + q) \sqrt{q})$.

Distribuim actualizările din bloc în noduri. Colectăm actualizările din bloc și le sortăm după timpul DFS. Este important să avem în vedere că nu toate actualizările se aplică tuturor interogărilor. Depinde de ordinea lor cronologică dinaintea sortării. Din punct de vedere al unui nod $u$, actualizările vor fi:

\begin{itemize}
  \item actualizări în afara subarborelui lui $u$;
  \item actualizări în $u$ însuși;
  \item actualizări în primul fiu al lui $u$;
  \item $\dots$
  \item actualizări în ultimul fiu al lui $u$;
  \item actualizări în afara subarborelui lui $u$.
\end{itemize}

Astfel putem afla trei cantități pentru fiecare interogare

\begin{enumerate}
  \item modificările din afara subarborelui (spre părinte);
  \item modificările pe cel mai populat fiu nemodificat;
  \item modificările pe fiecare fiu modificat.
\end{enumerate}

Calculăm aceste informații într-o singură trecere prin fiii lui $u$. Categoriile (1) și (2) cer efort $\bigoh(1)$, iar categoria (3) cere efort $\bigoh(1)$ per interogare, căci trebuie să decidem dacă modificarea se aplică fiecărei interogări sau nu.

\subsection{Problema Doi arbori (Lot 2024)}
\label{problem:doi-arbori}

\href{https://kilonova.ro/problems/2799}{enunț}
$\bullet$
\hyperref[code:doi-arbori]{surse}

Facem întîi o observație teoretică. Drumul cel mai scurt de la $G_u$ la $H_v$ este calea $u-v$ plus un ocol dus-întors de la unul dintre nodurile de pe calea $u-v$ la o frunză activă. Așadar problema se reduce la două subprobleme:

\begin{enumerate}
  \item (simplă) Aflarea distanțelor între noduri.
  \item (grea) Aflarea distanței minime de la orice drum de pe calea $u-v$ la o frunză activă.
\end{enumerate}

Facem și o altă observație: nodul 1 poate fi și el frunză (în sensul că poate avea grad 1). Dacă înrădăcinați arborele în nodul 1 ca toată lumea, aceasta poate fi o sursă de buguri. Pare totuși că testele nu acoperă acest caz.

\subsubsection*{Soluția cu HLD}

Să înrădăcinăm arborele în 1 și să construim HLD. Acum fie o interogare $(u,v)$ și fie $w=LCA(u,v)$. Prin definiție, orice cale în arbore întîi urcă, apoi coboară (și urcușul și coborîșul pot avea lungime 0). De aceea, cînd căutăm calea spre cea mai apropiată frunză activă de orice nod de pe calea $u-v$ este suficient să tratăm cazurile:

\begin{enumerate}
  \item Pornim dintr-un nod de pe cale și coborîm pînă la frunză.
  \item Pornim din $w$, urcăm și apoi coborîm.
\end{enumerate}

Vom stoca pe lanțuri informații care să ne permită să tratăm aceste două cazuri.

\textbf{Cazul I: Drumul spre frunză coboară}

Să considerăm unul dintre lanțurile vizitate pe calea $(u-w)$. Din acest lanț vom interoga o porțiune $[x,y]$. $x$ este fie capătul de sus al lanțului, fie $w$. $y$ este fie $u$, fie nodul în care se ancorează lanțul vizitat anterior.

Dacă drumul spre o frunză pornește chiar din $y$, atunci ne-ar ajuta să aflăm rapid adîncimea minimă a unei frunze active din subarborele lui $y$. Știm să facem asta cu un arbore de intervale $S_1$ cu actualizări punctuale și interogări de minim. La activarea unei frunze, notăm chiar adîncimea frunzei pe poziția corespunzătoare în liniarizare. La dezactivarea frunzei, notăm $\infty$. Putem afla adîncimea minimă a unei frunze din subarborele lui $y$ cu o interogare în $S_1$ pe intervalul subîntins de $y$. Distanța pînă la frunza $f$ este diferența de adîncimi dintre $f$ și $y$.

Dacă drumul spre frunză pornește de undeva dintr-un nod-ancoră $a \in [x,y)$, atunci distanța pînă la frunză este diferența de adîncimi dintre frunză și $a$. Desigur, nu vrem să interogăm fiecare nod din $[x,y)$, dar facem următoarea observație. O frunză de adîncime 30 ancorată într-un nod de adîncime 20 are aceeași distanță (10) ca și o frunză de adîncime 31 ancorată într-un nod de adîncime 21. De aceea, menținem un al doilea arbore de intervale $S_2$ care stochează pentru un nod $u$ \textbf{diferența} dintre adîncimea oricărei frunze din subarborele lui $u$ și adîncimea lui $u$.

\textbf{Cazul II: Drumul spre frunză urcă din $w$}

Vom urca pe lanțuri pînă la rădăcină. Din nou, fie $[x,y]$ porțiunea din lanțul curent pe care o interogăm.

Dacă drumul spre frunză pornește chiar din $y$, atunci ne interesează chiar adîncimea frunzei, iar din lanțul $w-y-\textrm{frunză}$ aflăm imediat distanța de la calea $u-v$ la frunză. Arborele de intervale $S_1$ este util și aici.

Dacă drumul spre frunza $f$ pornește dintr-un nod-ancoră $a \in [x,y)$, atunci distanța totală de la calea $u-v$ la $f$ este (notînd cu $d(u)$ adîncimea nodului $u$):

$$[d(w)-d(a)] + [d(f) - d(a)] = d(w) + [d(f) - 2 \cdot d(a)]$$

De aceea, avem nevoie de un al treilea arbore de intervale, $S_3$, care stochează pentru un nod $u$ diferența dintre adîncimea oricărei frunze din subarborele lui $u$ și \textbf{dublul} adîncimii lui $u$.

\textbf{Detaliu (esențial)}

La schimbarea stării unei frunze $f$ vom recalcula în arborii de intervale valorile următoarelor noduri:

\begin{itemize}
  \item frunza $f$;
  \item nodul în care se ancorează lanțul frunzei;
  \item nodul în care se ancorează lanțul anterior;
  \item etc.
\end{itemize}

Remarcăm, în particular, că frunza $f$ nu notifică alți strămoși de pe propriul ei lanț. Fie $x$ un astfel de strămoș. Se poate întîmpla următorul scenariu:

\begin{itemize}
  \item Frunza $f$ este activată.
  \item O altă frunză $f'$ din subarborele lui $x$ este activată.
  \item $f'$ declanșează actualizarea lui $x$, care va include și informații despre $f$.
  \item Frunza $f$ este deactivată.
  \item $x$ nu mai află niciodată despre dezactivarea lui $f$.
\end{itemize}

Soluția este ca, la propagarea în sus a unei modificări, să interogăm în $S_1$ \textbf{doar subarborele light al unui nod}. Ce modificare este necesară ca să putem identifica intervalul corespunzător din liniarizare?

\subsubsection*{Soluția cu descompunere în radical}

Menționez foarte pe scurt și o soluție în $\bigoh((n + q) \log q)$. Ea nu trece testele mari. Dar, în general, soluțiile cu descompunere în radical sînt o alternativă viabilă și posibil mai ușor de înțeles. Iar matematic $\sqrt{n}$ nu este departe de $\log^2 n$ pe plaja de valori pentru $n$ din problemele obișnuite.

Precalculăm liniarizarea Euler cu repetiție a arborelui, peste care construim tabela rară de RMQ. Astfel putem răspunde la interogări de LCA în $\bigoh(1)$ (avem nevoie de $\bigoh(1)$ deoarece vom face $\bigoh(q \sqrt{q})$ astfel de interogări).

Precalculăm \textit{binary lifting}, preferabil varianta cu doar doi pointeri. Astfel vom putea calcula în $\bigoh(\log n)$ o anumită informație pe căi.

Procesăm interogările în blocuri de mărime $\sqrt{q}$. Clasificăm frunzele active în două categorii:

\begin{enumerate}
  \item Frunze safe: frunze active pe durata întregului bloc.
  \item Frunze unsafe: frunze active pe porțiuni din bloc.
\end{enumerate}

La începutul fiecărui bloc, facem următoarea preprocesare în $\bigoh(n)$:

\begin{enumerate}
  \item Clasifică frunzele active în \textit{safe} și \textit{unsafe}.
  \item Calculează distanța minimă de la fiecare nod la o frunză \textit{safe}. Este suficient un BFS multi-sursă.
  \item Pentru fiecare pointer de salt, calculează distanța minimă de la orice nod acoperit de salt la o frunză \textit{safe}. Este suficient un DFS.
\end{enumerate}

Efortul total pentru preprocesări este $\bigoh(n \sqrt{q})$. Procesăm operațiile din bloc și ținem evidența mulțimii de frunze \textit{unsafe}. Pentru o interogare $(u,v)$, răspunsul va fi minimul dintre

\begin{enumerate}
  \item Distanța minimă de la cale la o frunză \textit{safe}, calculată în $\bigoh(\log n)$ cu \textit{jump pointers}.
  \item Pentru fiecare frunză \textit{unsafe} $f$, distanța $d(u, f) + d(f, v)$.
\end{enumerate}

Deoarece fiecare dintre cele $q$ interogări poate consulta $\bigoh(\sqrt{q})$ frunze \textit{unsafe}, efortul total este $\bigoh(q \log q)$ pentru interogări.

\subsubsection*{Momentul de inginerie: măsurarea timpului}

Pentru soluția cu descompunere în radical, nu am reușit să reduc timpul de rulare sub 4-5 secunde pe testele mari. Nevenindu-mi să cred că poate fi nevoie de atît de mult timp, am măsurat numărul de apeluri la diverse funcții și timpul petrecut în ele. Las aici codul pe care l-am folosit, în caz că îl ajută pe inginerul din voi.

\begin{minted}{c}
#include <sys/time.h>

long long t0, t_total, cnt;

void start_clock() {
  timeval tv;
  gettimeofday(&tv, NULL);
  t0 = 1'000'000LL * tv.tv_sec + tv.tv_usec;
}

void stop_clock() {
  timeval tv;

  gettimeofday(&tv, NULL);
  long long t = 1'000'000LL * tv.tv_sec + tv.tv_usec;
  t_total += t - t0;
}

int preprocess_block(int start) {
  cnt++;
  start_clock();   // <---------------
  int end = classify_leaves(start);
  bfs_from_safe_leaves();
  jdist_dfs(1);
  stop_clock();    // <---------------

  return end;
}

int main() {
  ...
  fprintf(stderr, "Time: %0.6lf cnt: %lld\n", t_total * 0.000001, cnt);
}
\end{minted}

\subsection{Problema Query on a Tree VI (CodeChef)}
\label{problem:qtree6}

\href{https://www.codechef.com/problems/QTREE6}{enunț}
$\bullet$
\hyperref[code:qtree6]{sursă}

Problema are un enunț simplu și elegant, dar este foarte laborioasă.

Am „trișat” un pic la rezolvare, căci știam că este problemă de HLD și mi-am pus întrebarea: HLD ne ajută să facem operații pe căi, deci cum aș folosi-o la o problemă despre subarbori? Așa am ajuns la o soluție parțială.

Definim \textbf{domeniul unui nod} $u$ ca fiind mulțimea de noduri din subarborele lui $u$, de aceeași culoare cu $u$, și legate de $u$ prin noduri de aceeași culoare. Fie $S(u) =$ mărimea domeniului lui $u$. Atunci, ca să răspundem la o interogare despre $u$, urcăm din $u$ cît timp se poate, mergînd pe noduri de aceeași culoare. Fie $w$ ultimul nod atins. Răspunsul este $S(w)$.

Dacă folosim HLD, îl putem găsi pe $w$ dacă menținem pe fiecare lanț un AIB de culori (0/1) cu suport pentru căutare binară.

Treburile se complică la actualizare. Cînd un nod $u$ își schimbă culoarea, schimbările necesare sînt:

\begin{enumerate}
  \item Toți strămoșii consecutivi care au vechea culoare a lui $u$ pierd $S(u)$ din domeniu.

  \item Recalculăm $S(u)$.

  \item Toți strămoșii consecutivi care au noua culoare a lui $u$ cîștigă $S(u)$ la domeniu.
\end{enumerate}

Operațiile (1) și (3) sînt operații de adăugare / scădere pe interval. Dar nu am reușit să implementez eficient operația (2). Astfel ajungem la soluția oficială. Menținem pentru fiecare nod \textbf{două valori}:

\begin{enumerate}
  \item $S_B(u)$ = mărimea domeniului lui $u$ dacă $u$ ar fi negru.
  \item $S_W(u)$ = mărimea domeniului lui $u$ dacă $u$ ar fi alb.
\end{enumerate}

Actualizarea acestor valori presupune niște cazuri particulare. De exemplu, dacă un nod $u$ devine alb, atunci toți strămoșii săi negri, \textbf{dar și primul strămoș alb}, pierd $S_B(u)$ din $S_B(w)$.

\subsubsection*{Temă de gîndire: „Aint pe timp”}

Am implementat și o \href{https://www.codechef.com/viewsolution/1120838233}{altă soluție} bazată pe metoda TODO:referință-internă ștergerii dintr-o structură care nu admite (ușor) ștergeri, cu un arbore de intervale indexat după timp. Problema fiind una de conectivitate online, ideea mi s-a părut bună. Dar am făcut o greșeală copilărească: aici nu activăm și dezactivăm muchii, ci noduri. Deci o operație poate cauza $\bigoh(n)$ operații în pădurea de mulțimi disjuncte. Sursa mea ia TLE pe teste adversariale.

Nu știu dacă putem reduce complexitatea. Voi ce credeți?

\subsection{Problema Adă caii (Lot 2025)}
\label{problem:ada-caii}

\href{https://kilonova.ro/problems/3819}{enunț}
$\bullet$
\hyperref[code:ada-caii]{sursă}

Să pornim de la o descompunere \textit{heavy-light} tradițională. Nu ne batem prea mult capul cu operația de interogare. Aceea este punctuală, deci probabil că orice structură vom construi peste lanțuri vom putea să aflăm o valoare punctuală. În schimb, să analizăm migrația spre un nod $u$. Observăm că:

\begin{enumerate}
  \item Pe un lanț $L$ aflat între $u$ și rădăcină, caii migrează către nodul în care calea către $u$ se desprinde din $L$.
  \item Pe alte lanțuri, caii migrează în sus.
  \item Caii pot sări de pe un lanț pe altul.
\end{enumerate}

De exemplu, în figura \ref{fig:tree-heavy-light-2}, migrația către nodul 28 (albastru-deschis) înseamnă că:

\begin{enumerate}
  \item Pe lanțul roșu 1-30, caii migrează către nodul 20.
  \item Caii din nodul 20 coboară pe lanțul violet în nodul 32.
  \item Pe lanțul violet 32-19 caii migrează către nodul 14.
  \item Caii din nodul 14 coboară pe lanțul albastru deschis în nodul 38.
  \item Pe alte lanțuri, caii migrează în sus.
  \item Caii aflați în nodurile din vîrful altor lanțuri migrează pe lanțul-părinte.
\end{enumerate}

Așadar, pe fiecare lanț dorim să stocăm o structură de date care implementează rezonabil de eficient operațiile:

\begin{enumerate}
  \item Migrează toate valorile spre stînga (spre rădăcină).
  \item Migrează toate valorile spre o poziție din structură.
  \item Citește / modifică o poziție.
\end{enumerate}

Operațiile (1) și (3) sînt ușor de implementat în $\bigoh(1)$ cu un buffer circular pe fiecare lanț. Am ales să stochez aceste buffere într-un singur vector global, separat de nodurile arborelui.

În schimb, operația (2) pare a fi $\bigoh(\textrm{lungime\_lanț})$. De aceea, vom pune o limită de $\bigoh(\sqrt{n})$ pe lungimea oricărui lanț. Dacă un lanț ar fi, în mod natural, mai lung de atît, după primele $\bigoh(\sqrt{n})$ noduri vom forța începerea unui lanț nou. Aceasta va cauza apariția mai multor lanțuri, dar nu multe.

Cu această modificare, și pentru o optimizare posibil valoroasă, vom implementa (2) copiind naiv jumătatea mai scurtă a vectorului și shiftînd-o pe cea mai lungă conform bufferului circular.

În plus, ținem evidența lanțurilor nevide, deoarece doar pe acelea avem de implementat operația (1). Pot exista $\bigoh(n)$ lanțuri, de exemplu într-un arbore stea, dar pare imposibil să menținem populații de cai pe $\bigoh(n)$ lanțuri. Cu fiecare operație de migrare, unele populații de cai se vor ciocni și se vor însuma.

Sînt 99\% sigur că acest algoritm este eficient, dar demonstrația este alunecoasă. Intuiția mea îmi spune astfel. Temerea noastră este că poate exista o migrație (sau mai multe) care să necesite efort $\bigoh(n)$. Aceasta s-ar putea întîmpla dacă există $\bigoh(\sqrt{n})$ lanțuri pe calea de la $u$ la rădăcină (datorită limitei de lungime), iar pe fiecare lanț este nevoie să facem operația (2) și să copiem naiv $\bigoh(\sqrt{n})$ elemente.

Dar, dacă drumul de la $u$ la rădăcină include vreun lanț complet, pe acela nu vom face efort $\bigoh(\textrm{lungime})$, ci doar $\bigoh(1)$, deoarece migrația în acel lanț va fi doar în jos, spre $u$! De exemplu, în figura \ref{fig:tree-heavy-light-2}, pentru $u = 30$ elementele de pe lanțul roșu migrează doar în jos.

De aceea, un caz adversarial ar fi o cale de la $u$ la rădăcină care, ori de cîte ori schimbă lanțul, se „înțeapă” undeva la jumătatea noului lanț. Or acest lucru este imposibil datorită modului în care funcționează decompunerea \textit{heavy-light}. Din punct de vedere al nodului de înțepare, lanțul ar prefera să continue pe calea spre $u$, dacă aceasta este destul de lungă. Așadar, dacă am avea $\bigoh(\sqrt{n})$ lanțuri, toate de lungime $\bigoh(\sqrt{n})$, numărul total de noduri de pe acea cale ar deveni $\bigoh(n)$ și majoritatea lanțurilor s-ar înțepa în capătul de jos al lanțului anterior.
